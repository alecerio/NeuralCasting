from neural_cast.frontend.parser.node.node import Node
from neural_cast.frontend.parser.node.input_node import InputNode
from neural_cast.frontend.exceptions.CompilerException import CompilerException
from neural_cast.frontend.common.common import fix_identifier
from neural_cast.frontend.common.common import onnx_type_to_c_dictionary
import math

class InitializerNode(Node):
    def __init__(self, name : str, tensor, data_type):
        super().__init__(name=name)
        self._tensor = tensor
        self._data_type = data_type
        self._outputs : list[Node] = []
    
    def __str__(self):
        super_str : str = super().__str__()
        tensor_str = "tensor:\n" + str(self._tensor)
        data_type_str = "data type: " + str(self._data_type)
        outputs_name : str = "output nodes: "
        for output in self._outputs:
            outputs_name = outputs_name + output.get_name() + ", " 
        return  super_str + "\n" + \
                tensor_str + "\n" + \
                data_type_str + "\n" + \
                outputs_name
    
    def set_tensor(self, tensor):
        self._tensor = tensor

    def get_tensor(self):
        return self._tensor
    
    def set_data_type(self, data_type):
        self._data_type = data_type

    def get_data_type(self):
        return self._data_type

    def append_output_node(self, node : Node):
        if isinstance(node, InputNode):
            raise CompilerException("Error: an input node can't be an output node")
        self._outputs.append(node)
    
    def remove_output_node_by_name(self, name : str):
        index : int = self._get_output_node_index_by_name(name)
        if index == -1:
            raise CompilerException("Error: output not found in input node")
        self._outputs.pop(index)

    def remove_output_node_by_index(self, index : int):
        if index == -1:
            raise CompilerException("Error: output not found in input node")
        self._outputs.pop(index)

    def get_output_node_by_name(self, name : str) -> Node:
        index : int = self._get_output_node_index_by_name(name)
        if index == -1:
            raise CompilerException("Error: output not found in input node")
        return self._outputs[index]

    def get_output_node_by_index(self, index : int) -> Node:
        if index == -1:
            raise CompilerException("Error: output not found in input node")
        return self._outputs[index]

    def get_output_nodes_name(self) -> list[str]:
        names : list[str] = []
        for output in self._outputs:
            name = output.get_name()
            names.append(name)

    def num_output_nodes(self) -> int:
        return len(self._outputs)

    def get_output_nodes_list(self) -> list[Node]:
        return self._outputs

    def _get_output_node_index_by_name(self, name : str) -> int:
        for i in range(len(self._outputs)):
            node : Node = self._outputs[i]
            if node.get_name() == name:
                return i
        return -1
    
    def generate_code(self) -> str:
        return ""

    def generate_includes_code_c(self) -> str:
        return ""

    def generate_declaration_code_c(self) -> str:
        tensor_flat = self._tensor.flatten()
        size : int = len(tensor_flat)
        elem_type : int = self.get_data_type()
        elem_type_str : str = onnx_type_to_c_dictionary(elem_type)
        code : str = "static " + elem_type_str + " tensor_" + fix_identifier(self.get_name()) + "[" + str(size) + "] = {"
        for i in range(size):
            code += str(tensor_flat[i]) + ", "
        code += "};\n\n"
        return code
    
    def infer_output_type(self) -> int:
        elem_type : int = self.get_data_type()
        return elem_type

    def infer_output_shape(self) -> list[list[int]]:
        shape = self.get_tensor().shape
        if len(shape) == 1:
            shape = [1, shape[0]]
        return shape
